# 진짜 모르겠다 나는 DP가 너무 어렵다.
# DP는 우선 GPT한테 물어보고 기본적인 원리를 파악하는 방식으로 공부해야겠다.

# dp 일차원 배열을 만든다.
# dp[i] => i를 1로 만들기 위해 필요한 최소 연산 수
# N을 1로 만들고 싶다면 N+1 길이의 dp 배열을 준비한 후 1부터 차례대로 구해주는 것이다.

N = int(input())

dp = [0]*(N+1)    # dp 배열

for i in range(2, N+1):
    # 우선 기본적으로 1을 빼주는 연산을 진행한다.
    dp[i] = dp[i-1] + 1    # 연산 한 번 진행했으니 +1

    # 그 후 만약 i가 2로 나누어 떨어지거나 3으로 나누어 떨어질 경우 나누어 떨어졌을 때의 연산 횟수와 기존 연산 횟수를 비교하여 더 작은 것을 선택한다.
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)

    # if i % 6 == 0:
    #     dp[i] = min(dp[i-1]. dp[i//2] + 1, dp[i//3] + 1)
    # 얘는 필요가 없다 어차피 앞에서 2, 3 순으로 봐줬기 때문에 이미 다 고려가 되어있다.

print(dp[N])